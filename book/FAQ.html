<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>FAQ</title>
  <meta name="description" content="FAQ" />
  <meta name="generator" content="bookdown 0.13 and GitBook 2.6.7" />

  <meta property="og:title" content="FAQ" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="FAQ" />
  
  
  

<meta name="author" content="Team Algoritma" />


<meta name="date" content="2020-01-22" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path=""><a href="#forewords"><i class="fa fa-check"></i>Forewords</a></li>
<li class="chapter" data-level="" data-path=""><a href="#disclaimer"><i class="fa fa-check"></i>Disclaimer</a></li>
<li class="chapter" data-level="1" data-path=""><a href="#regression-model"><i class="fa fa-check"></i><b>1</b> Regression Model</a></li>
<li class="chapter" data-level="2" data-path=""><a href="#classification-1"><i class="fa fa-check"></i><b>2</b> Classification 1</a><ul>
<li class="chapter" data-level="2.1" data-path=""><a href="#imbalance-target-variable"><i class="fa fa-check"></i><b>2.1</b> Imbalance Target Variable</a><ul>
<li class="chapter" data-level="2.1.1" data-path=""><a href="#downsample"><i class="fa fa-check"></i><b>2.1.1</b> Downsample</a></li>
<li class="chapter" data-level="2.1.2" data-path=""><a href="#upsample"><i class="fa fa-check"></i><b>2.1.2</b> Upsample</a></li>
<li class="chapter" data-level="2.1.3" data-path=""><a href="#downsampleupsample-using-recipes"><i class="fa fa-check"></i><b>2.1.3</b> Downsample/Upsample Using <code>Recipes</code></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path=""><a href="#classification-2"><i class="fa fa-check"></i><b>3</b> Classification 2</a></li>
<li class="chapter" data-level="4" data-path=""><a href="#unsupervised-learning"><i class="fa fa-check"></i><b>4</b> Unsupervised Learning</a></li>
<li class="chapter" data-level="5" data-path=""><a href="#time-series-and-forecasting"><i class="fa fa-check"></i><b>5</b> Time Series and Forecasting</a></li>
<li class="chapter" data-level="6" data-path=""><a href="#neural-network-and-deep-learning"><i class="fa fa-check"></i><b>6</b> Neural Network and Deep Learning</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">FAQ</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">FAQ</h1>
<p class="author"><em>Team Algoritma</em></p>
<p class="date"><em>January 22, 2020</em></p>
</div>
<div id="forewords" class="section level1 unnumbered">
<h1>Forewords</h1>
<p>Algoritma providing workshop to help working professionals and students to achieve basic and advanced skill in various data science sub-fields, including: data visualization, machine learning, data modeling, statistical inference etc.</p>
</div>
<div id="disclaimer" class="section level1 unnumbered">
<h1>Disclaimer</h1>
<p>This coursebook is produced by Team <a href="algorit.ma" target="_blank">Algoritma</a> for its Data Science Academy workshops. No part of this coursebook may be reproduced in any form without permission from the author, and is inteded for restricted audiences that participate on the workshop.</p>

</div>
<div id="regression-model" class="section level1">
<h1><span class="header-section-number">Chapter 1</span> Regression Model</h1>
<ol style="list-style-type: decimal">
<li><p>Bagaimana penanganan data kategorik pada model linear regression?</p>
<p>Dengan menggunakan function <code>lm</code> pada R otomatis akan mengubah tipe data kategorik menjadi dummy variabel. Dummy variable berfungsi untuk mengkuantitatifkan variabel yang bersifat kualitatif (kategorik). Dummy variabel hanya mempunyai dua nilai yaitu 1 dan 0. Dummy memiliki nilai 1 untuk salah satu kategori dan nol untuk kategori yang lain. Jika terdapat sebanyak <code>k</code> kategori untuk suatu prediktor maka akan ditransformasi menjadi <code>k-1</code> dummy.</p></li>
<li><p>Mengapa untuk asumsi normality yang harus berdistribusi normal adalah error/residual ?</p>
<p>Jika residual berdistribusi normal, itu artinya residual cenderung berkumpul di titik sekitar 0, dapat dikatakan hasil prediksi tidak terlalu melenceng jauh dari data actual.</p>
<p>Error yang tidak berdistribusi normal disebabkan oleh:</p></li>
</ol>
<ul>
<li>distribusi target variabel memang tidak normal</li>
<li>Model yang digunakan tidak cocok, misal hubungan antara prediktor dengan target tidak linier melainkan kudratik/eksponensial/dll walaupun target variabel memiliki distribusi normal.</li>
<li>Selain itu, error harus berdistribusi normal terkait dengan pengujian-pengujian parameter (beta/koefisien regresi) secara statistik (F-test, t-test, dan confidence interval).</li>
<li>Terdapat banyak data outlier</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><p>Mengapa untuk asumsi normality yang harus berdistribusi normal adalah error/residual ?</p>
Karena ingin melihat kecocokan model. Error yang tidak berdistribusi normal disebabkan oleh:</li>
</ol>
<ul>
<li>distribusi target variabel memang tidak normal</li>
<li>Model yang digunakan tidak cocok, misal hubungan antara prediktor dengan target tidak linier melainkan kudratik/eksponensial/dll walaupun target variabel memiliki distribusi normal.</li>
<li>Selain itu, error harus berdistribusi normal terkait dengan pengujian-pengujian parameter (beta/koefisien regresi) secara statistik (F-test, t-test, dan confidence interval).</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li><p>Untuk prediktor kategorik, bagaimana jika terdapat kategori yang tidak signifikan (p value &gt; alpha)? apakah prediktor tersebut masih dianggap signifikan mempengaruhi target?</p>
<p>Untuk variabel kategorik ketika salah satu variabel signifikan, kita anggap levels lainnya juga signifikan.</p></li>
<li><p>Pada fungsi <code>lm</code> sudah otomatis melakukan transformasi data kategorik dengan level pertama yang dijadikan basis. Bagaimana jika dilakukan reorder level (mengubah urutan level), apakah akan mengubah hasil pemodelan?</p>
<p>Hasil pemodelan tidak akan berubah, mengubah urutan level hanya akan mengubah basis yang digunakan.</p></li>
<li><p>Bagaimana jika terdapat prediktor yang tidak signifikan, tetapi secara bisnis seharusnya prediktor tersebut berpengaruh terhadap target?</p>
<p>Ketika variabel yang kita gunakan tidak signifikan secara statistik, namun secara bisnis berpengaruh terhadap target yang dimiliki, kita akan tetap mempertahankan variabel tersebut, banyak faktor yang menyebabkan variabel tersebut tidak signikan, bisa jadi karena data yang dimiliki tidak cukup banyak, banyak data oulier, atau ragam data yang hanya sedikit.</p></li>
<li><p>Mengapa perlu dilakukan pengecekkan asumsi pada metode regresi linier?</p>
<p>Pengecekkan asumsi dilakukan terkait dengan pengujian-pengujian parameter (beta/koefisien regresi) secara statistik (F-test, t-test, dan confidence interval). Ketika semua asumsi terpenuhi model dapat dikatakan <code>BLUE</code> (Best Linear Unbiased Estimator).</p></li>
<li><p>Jika sudah dilakukan berbagai alternatif untuk pemenuhan asumsi, namun masih terdapat asumsi yang tidak terpenuhi apa yang harus dilakukan?</p>
<p>Ketika sudah dilakukan berbagai alternatif untuk memenuhi asumsi namun asumsi masih tidak terpenuhi, itu artinya data yang kita miliki tidak cocok menggunakan regresi linear, dapat dicoba dengan model lain.</p></li>
<li><p>Bagaimana jika diperoleh nilai AIC negatif?</p>
<p>AIC dapat bernilai negatif atupun positif yang disebabkan oleh nilai dari fungsi maksimum likelihood berikut:</p>
<p><code>AIC = 2k − 2ln(L)</code>, dimana <code>k</code> merupakan jumlah parameter (jumlah prediktor dan intersep) dan <code>L</code> merupakan nilai dari fungsi maksimum likelihood.</p>
<p>Namun, pada pemilihan model nilai AIC yang dilihat adalah nilai AIC yang sudah diabsolutkan. Sehingga tanda negatif/positif pada hasil AIC tidak berpengaruh dalam proses pemilihan model. Model yang dipilih adalah model yang memiliki nilai abolut AIC terkecil, hal ini mengindikasikan bahwa semakin sedikit model tersebut kehilangan informasi yang dibawa. <a href="https://stats.stackexchange.com/questions/84076/negative-values-for-aic-in-general-mixed-model">Negative values for AIC</a></p></li>
<li><p>Perbedaan dari R-squared dan Adjusted R-squared?</p>
<p>R-squared memperhitungkan variasi dari semua variabel independen terhadap variabel dependen. Sehingga setiap penambahan variabel independen akan meningkatkan nilai R-squared. Sedangkan pada adjusted r-squared akan memperhitungan variasi dari variabel independen yang signifikan terhadap variabel dependen. Oleh karena itu, pada multiple linear regression disarankan untuk melihat nilai Adjusted R-squared.</p></li>
<li><p>Apa itu outlier?</p>
<p>Data observasi yang terlihat sangat berbeda jauh dari observasi-observasi lainnya dan muncul dalam bentuk nilai ekstrim baik untuk sebuah variabel tunggal atau kombinasi.</p></li>
<li><p>Cara yang dapat dilakukan untuk tuning model regresi?</p>
<p>Banyak cara yang dapat dilakukan untuk tuning model regresi, salah satunya adalah dengan deteksi outlier pada data observasi. Deteksi outlier dari data yang dimiliki, apakah dengan atau tanpa data outlier tersebut akan mengganggu perfomance model yang dimiliki.</p></li>
<li><p>Untuk apa ada p-value di output regresi jika sebelumnya kita sudah melakukan uji korelasi?</p>
<p>Uji korelasi pada preprocessing data dilakukan untuk melihat secara umum apakah variabel prediktor dan target terdapat hubungan kuat atau tidak. Sedangkan uji pvalue pada output regresi pada setiap variabel prediktor menyatakan apakah setiap variabel prediktor benar-benar mempengaruhi target secara statistik atau tidak.</p></li>
<li><p>Uji statistik apa yang dapat digunakan untuk uji normalitas dengan lebih dari 5000 observasi?</p></li>
</ol>
<p>Uji normalitas dengan observasi yang lebih dari 5000 dapat menggunakan uji Kolmogorov Smirnov dengan code sebagai berikut:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">ks.test</span>(model<span class="op">$</span>residuals, <span class="st">&quot;pnorm&quot;</span>, <span class="dt">mean =</span> <span class="kw">mean</span>(model<span class="op">$</span>residuals), <span class="dt">sd =</span> <span class="kw">sd</span>(model<span class="op">$</span>residuals))</a></code></pre></div>
<ol start="15" style="list-style-type: decimal">
<li><p>Bagaimana jika target variabel yang dimiliki berupa bilangan diskrit, apakah bisa dilakukan analisis regresi?</p>
<p>Untuk analisis regresi dengan target variabel berupa bilangan diskrit dapat menggunakan regressi poisson. Untuk detail lengkapnya dapat dilihat di link berikut: <a href="https://algotech.netlify.com/blog/poisson-regression-and-neg-ative-binomial-regression/">link</a></p></li>
</ol>

</div>
<div id="classification-1" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> Classification 1</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1"><span class="co"># libraries</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">library</span>(tidyverse)</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">library</span>(rsample)</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">library</span>(caret)</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">library</span>(recipes)</a></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Pada klasifikasi penentuan kelas didasarkan pada peluang, bagaimana jika peluang yang diperoleh sama besar, misal pada kasus klasifikasi biner diperoleh peluang masuk ke kelas 1 adalah 0.5 dan peluang masuk ke kelas 0 adalah 0.5?</p>
<p>Hal tersebut bergantung pada user yang menentukan threshold/batasan probability untuk masuk ke kelas 1 atau masuk ke kelas 0. Namun, pada umumnya jika diperoleh probability &gt;= 0.5 maka observasi tersebut akan masuk ke kelas 1.</p></li>
<li><p>Untuk prediktor kategorik, bagaimana jika terdapat kategori yang tidak signifikan (p value &gt; alpha)? apakah prediktor tersebut masih dianggap signifikan mempengaruhi target?</p></li>
</ol>
<p>Untuk level yang menjadi basis akan dianggap signifikan, untuk level lainnya yang tidak signifikan artinya memang level tersebut tidak memberikan pengaruh terhadap target variabel. Solusi yang dapat dilakukan adalah bining (level tersebut dijadikan satu level yg mirip dan signifikan) atau menambahkan jumlah observasi pada level yang tidak signifikan tersebut.</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Pada fungsi <code>lm</code> sudah otomatis melakukan transformasi data kategorik dengan level pertama yang dijadikan basis. Bagaimana jika dilakukan reorder level (mengubah urutan level), apakah akan mengubah hasil pemodelan?</p>
<p>Nilai pvalue pada setiap level tidak akan berubah ketika kita melakukan reorder level. Interpretasi untuk variable kategorik bergantung pada level yang dijadikan basis</p></li>
<li><p>Pengertian dari null deviance dan residual deviance pada output summary?</p>
<p>Null deviance menunjukkan seberapa baik target variabel diprediksi oleh model berdasarkan nilai intercept. Sedangkan residual deviance menunjukkan seberapa baik target variabel diprediksi oleh model berdasarkan intercept dan semua variabel independen yang digunakan.</p></li>
</ol>
<p>Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi<br />
<a href="https://www.theanalysisfactor.com/r-glm-model-fit/">link</a></p>
<ol start="5" style="list-style-type: decimal">
<li><p>Apa itu <code>Fisher Scoring</code> pada output summary?</p>
<p>Fisher scoring adalah turunan dari metode Newton untuk mengatasi Maximum Likelihood. Fisher scoring memberikan informasi berapa banyak iterasi yang dilakukan pada model sehingga diperoleh nilai parameter.</p></li>
<li><p>Apa itu Maximum Likelihood Estimator (MLE)?</p>
<p>Parameter pada model logistik regression diperoleh dari pendekatan MLE. MLE merupakan pendekatan statistik untuk memperkirakan paramater pada model.</p></li>
<li><p>Pada kasus klasifikasi, kenapa matrix accuracy tidak cukup menjelaskan seberapa baik model yang diperoleh?</p>
<p>Untuk mengetahui seberapa baik perfomance model klasifikasi, tidak cukup dengan melihat nilai accuracy nya saja, karena accuracy menganggap sama penting untuk nilai false positive dan false negative. Kita membutuhkan perhitungan lain seperti precision dan recall, contohnya untuk memprediksi pasien mengidap kanker jinak atau ganas. Tentunya akan lebih berbahaya jika kemampuan model yang kita miliki cenderung lebih baik memprediksi kanker ganas namun terprediksi menjadi jinak. Pada kasus ini karena kelas positif yang dimiliki adalah kanker ganas, maka kita akan mementingkan nilai recall lebih besar dibandingkan nilai pengukuran lainnya.</p></li>
<li><p>Permasalahan apa yang paling sering ditemui pada kasus klasifikasi?</p>
<p>Permasalahan besar kasus klasifikasi adalah dataset yang tidak seimbang. Contohnya pada case churn telekomunikasi, employee attrition, prediksi kankes, fraud detection, dan sebagainya. Dalam hal tersebut, biasanya jumlah kelas positif jauh lebih sedikit dibandingkan kelas negatif.</p>
<p>Misalkan pada kasus fraud detection, dari 1000 transaksi yang dimiliki, 10 diantaranya fraud, sedangkan sisanya tidak fraud. Kemudian perfomance model yang diperoleh sekitar 85%, mungkin terdengar sangat baik, namun pada kenyatannya tidak. Kemungkinan besar model tersebut hanya mampu memprediksi salah satu kelas kelas mayoritas yaitu yang tidak fraud, sedangkan kelas positif yang kita miliki sangat sedikit data yang dimiliki.</p></li>
</ol>
<div id="imbalance-target-variable" class="section level2">
<h2><span class="header-section-number">2.1</span> Imbalance Target Variable</h2>
<p>Pemodelan klasifikasi mulai banyak digunakan pada berbagai bidang industri, seperti perbankan untuk mendeteksi transaksi yang memiliki kecenderungan kecurangan atau memprediksi potensi kegagalan nasabah dalam membayar kredit/hutang, tranportasi (penerbangan) untuk memprediksi kemungkinan suatu penerbangan mengalami keterlambatan, digital marketing untuk memprediksi pelanggan yang loyal atau pelanggan yang memiliki potensi untuk kembali membeli produk yang dijual, kesehatan untuk memprediksi apakah seorang pasien positif terkena penyakit tertentu, dan masih banyak lagi.</p>
<p>Dari berbagai macam permasalahan klasifikasi tersebut tidak semua masalah klasifikasi memiliki jumlah target variabel yang seimbang (level yang mendominasi keseluruhan target merupakan kelas mayoritas dan level yang lebih kecil disebut kelas minoritas). Ketika kondisi seperti apa target variabel tidak memiliki proporsi yang seimbang ?</p>
<p><img src="assets/03-C1/imbalance%20proportion.png" /></p>
<p>Hal tersebut akan berpengaruh terhadap kemampuan model untuk memprediksi target (model klasifikasi cenderung lebih pintar dalam memprediksi kelas mayoritas), karena model klasifikasi sangat bergantung pada jumlah setiap level target dalam proses learning nya (model klasifikasi akan melalui proses learning yang seimbang jika diberikan jumlah sampel yang seimbang pula). Hal ini menjadi masalah yang cukup serius, sehingga perlu dilakukan penanganan sebagai solusi permasalahan tersebut.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">attrition &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/02-C1/attrition.csv&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">attrition =</span> <span class="kw">as.factor</span>(attrition))</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">prop.table</span>(<span class="kw">table</span>(attrition<span class="op">$</span>attrition)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>#&gt; 
#&gt;   no  yes 
#&gt; 0.84 0.16</code></pre>
<p>Salah satu cara yang paling umum dilakukan adalah menyeimbangkan jumlah target variabel dengan metode sampling. Metode tersebut terbagi menjadi 2, yaitu <strong>downsampling</strong> dan <strong>upsampling</strong>.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Downsampling</strong> adalah proses sampling pada observasi kelas mayoritas sebanyak jumlah observasi pada kelas minoritas, tujuannya adalah menyamakan jumlah observasi pada kelas mayoritas dan minoritas. Sehingga model klasifikasi dapat melalui proses learning yang seimbang. Proses downsampling akan mengurangi jumlah observasi pada kelas mayoritas, sehingga memungkinkan terjadinya kehilangan informasi.</p></li>
<li><p><strong>Upsampling</strong> adalah proses sampling pada observasi kelas minoritas sebanyak jumlah observasi pada kelas mayoritas, tujuannya adalah menyamakan jumlah observasi pada kelas mayoritas dan minoritas. Sehingga model klasifikasi dapat melalui proses learning yang seimbang. Proses upsampling akan menambah jumlah observasi pada kelas minoritas, sehingga memungkinkan terdapat data yang duplicate pada kelas minoritas.</p></li>
</ol>
<p>Untuk melakukan downsampling dan upsampling dapat menggunakan fungsi pada library <code>caret</code> ataupun <code>recipes</code>. Berikut contoh downsampling dan upsampling dengan menggunakan fungsi pada library <code>caret</code> dan <code>recipes</code></p>
<p>Sebelum menerapkan downsampling dan upsamling terlebih dahulu dilakukan cross validation, yaitu membagi data menjadi <strong>training set</strong> untuk proses pemodelan dan <strong>testing set</strong> untuk melakukan evaluasi. Cross validation akan dilakukan dengan menggunakan fungsi <code>initial_split()</code> dari library <code>rsample</code>. Fungsi tersebut akan melakukan proses sampling untuk cross validation dengan metode <strong>stratified random sampling</strong>, sehingga proporsi target variabel pada data awal, akan dipertahankan baik pada training set maupun testing set.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># define seed</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">set.seed</span>(<span class="dv">100</span>)</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co"># menentukan indeks untuk train dan test</span></a>
<a class="sourceLine" id="cb6-5" title="5">splitted &lt;-<span class="st"> </span><span class="kw">initial_split</span>(<span class="dt">data =</span> attrition, <span class="dt">prop =</span> <span class="fl">0.75</span>, <span class="dt">strata =</span> <span class="st">&quot;attrition&quot;</span>)</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co"># mengambil indeks data train dengan fungsi `tarining()`</span></a>
<a class="sourceLine" id="cb6-8" title="8">train &lt;-<span class="st"> </span><span class="kw">training</span>(splitted)</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co"># mengambil indeks data test dengan fungsi `testing()`</span></a>
<a class="sourceLine" id="cb6-11" title="11">test &lt;-<span class="st"> </span><span class="kw">testing</span>(splitted)</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">prop.table</span>(<span class="kw">table</span>(train<span class="op">$</span>attrition)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>#&gt; 
#&gt;   no  yes 
#&gt; 0.84 0.16</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">prop.table</span>(<span class="kw">table</span>(test<span class="op">$</span>attrition)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>#&gt; 
#&gt;   no  yes 
#&gt; 0.84 0.16</code></pre>
<p>Downsampling dan upsampling hanya akan dilakukan pada data train karena proses pembuatan model klasifikasi hanya dilakukan pada data train. Data test hanya digunakan untuk mengevaluasi model yang dihasilkan pada data train.</p>
<div id="downsample" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Downsample</h3>
<p>Untuk melakukan downsampling dengan library <code>caret</code> dapat menggunakan fungsi <code>downSample()</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1">train_down &lt;-<span class="st"> </span><span class="kw">downSample</span>(<span class="dt">x =</span> train[, <span class="dv">-1</span>], <span class="dt">y =</span> train<span class="op">$</span>attrition, <span class="dt">yname =</span> <span class="st">&quot;attrition&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">prop.table</span>(<span class="kw">table</span>(train_down<span class="op">$</span>attrition)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>#&gt; 
#&gt;  no yes 
#&gt; 0.5 0.5</code></pre>
</div>
<div id="upsample" class="section level3">
<h3><span class="header-section-number">2.1.2</span> Upsample</h3>
<p>Untuk melakukan upsampling dengan library <code>caret</code> dapat menggunakan fungsi <code>upSample()</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1">train_up &lt;-<span class="st"> </span><span class="kw">upSample</span>(<span class="dt">x =</span> train[, <span class="dv">-1</span>], <span class="dt">y =</span> train<span class="op">$</span>attrition, <span class="dt">yname =</span> <span class="st">&quot;attrition&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">prop.table</span>(<span class="kw">table</span>(train_up<span class="op">$</span>attrition)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>#&gt; 
#&gt;  no yes 
#&gt; 0.5 0.5</code></pre>
<p>Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://rdrr.io/cran/caret/man/downSample.html">downSample: Down- and Up-Sampling Imbalanced Data</a></p>
</div>
<div id="downsampleupsample-using-recipes" class="section level3">
<h3><span class="header-section-number">2.1.3</span> Downsample/Upsample Using <code>Recipes</code></h3>
<p>Sama seperti saat menggunakan fungsi pada library <code>caret</code>, ketika menggunakan fungsi dari library <code>recipes</code> juga harus dilakukan cross validation terlebih dahulu. Perbedaan ketika menggunakan fungsi dari library <code>recipes</code> data train dan data test tidak langsung dimasukkan ke dalam sebuah objek melainkan dilakukan downsampling atau upsampling terlebih dahulu.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">set.seed</span>(<span class="dv">417</span>)</a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3">splitted_rec &lt;-<span class="st"> </span><span class="kw">initial_split</span>(<span class="dt">data =</span> attrition, <span class="dt">prop =</span> <span class="fl">0.8</span>, <span class="dt">strata =</span> <span class="st">&quot;attrition&quot;</span>)</a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5">splitted_rec</a></code></pre></div>
<pre><code>#&gt; &lt;1177/293/1470&gt;</code></pre>
<p>Untuk melakukan downsampling atau upsampling menggunakan library <code>recipes</code> dapat menggunakan fungsi <code>step_downsample()</code> atau <code>step_upsample()</code> yang didefinisikan dalam sebuah <strong>recipe</strong>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" title="1">rec &lt;-<span class="st"> </span><span class="kw">recipe</span>(attrition <span class="op">~</span><span class="st"> </span>., <span class="kw">training</span>(splitted)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="st">  </span><span class="co"># `step_downsample()` dapat diganti dengan `step_upsample()`</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="st">  </span><span class="kw">step_downsample</span>(attrition, <span class="dt">ratio =</span> <span class="dv">1</span>, <span class="dt">seed =</span> <span class="dv">100</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="st">  </span><span class="kw">prep</span>()</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1"><span class="co"># membuat data train dengan fungsi `juice()`</span></a>
<a class="sourceLine" id="cb20-2" title="2">train_rec &lt;-<span class="st"> </span><span class="kw">juice</span>(rec)</a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="co"># membuat data test dengan fungsi `bake()`</span></a>
<a class="sourceLine" id="cb20-5" title="5">test_rec &lt;-<span class="st"> </span><span class="kw">bake</span>(rec, <span class="kw">testing</span>(splitted))</a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">prop.table</span>(<span class="kw">table</span>(train_rec<span class="op">$</span>attrition)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dv">2</span>)</a></code></pre></div>
<pre><code>#&gt; 
#&gt;  no yes 
#&gt; 0.5 0.5</code></pre>
<p>Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://github.com/tidymodels/recipes">tidymodels/recipes</a></p>
<ol start="9" style="list-style-type: decimal">
<li>Apa yang dimaksud dengan false positive dan false negative?</li>
</ol>
<ul>
<li><p>False positive adalah kasus dimana sisi negatif terprediksi sebagai positif. Contohnya, pasien terprediksi mengidap kanker ganas, namun data actual nya pasien tersebut mengidap kanker jinak.</p></li>
<li><p>False negative adalah kasus dimana sisi positif terprediksi sebagai negatif.
Contohnya, pasien teprediksi mengidap kanker jinak, namun data actual nya pasien tersebut mengidap kanker ganas.</p></li>
</ul>
<ol start="10" style="list-style-type: decimal">
<li><p>Bagaimana model regresi logistic regression menangani data kategorik?</p>
<p>Sama seperti kasus linear regression, pada logistic regression akan mengubah variabel kategorik menjadi dummy variabel.</p></li>
<li><p>Apa maksud dari nilai AIC?</p>
<p>AIC (Akaike Information Criterion) menggambarkan seberapa banyak informasi yang hilang pada model tersebut. AIC biasa digunakan untuk membandingkan beberapa model, karena berbeda dengan R-squared yang memiliki range semakin mendekati 1 semakin baik, AIC tidak memiliki batasan, jadi kita perlu membandingkannya dengan model lain.</p></li>
<li><p>Jelaskan kegunaan dari ROC dan AUC?</p>
<p>Kurva ROC (Receiver Operating Characteristic) menggambarkan seberapa baik kinerja model klasifikasi biner. Kurva ROC dibentuk dari nilai TPR (True Positive Rate) dan FPR (False Positive Rate) untuk semua nilai threshold dari 0 hingga 1. AUC (Area Under the Curve) adalah luas daerah dari kurva ROC. Nilai AUC mendekati 1 artinya model sangat baik, ketika nilai AUC berada di sekitar 0.5 maka model tersebut memiliki performance yang tidak baik dan cenderung hanya menebak secara acak.</p></li>
</ol>

</div>
</div>
</div>
<div id="classification-2" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Classification 2</h1>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" title="1"><span class="co"># libraries</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">library</span>(tidyverse)</a>
<a class="sourceLine" id="cb23-3" title="3"><span class="kw">library</span>(e1071)</a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">library</span>(tm)</a>
<a class="sourceLine" id="cb23-5" title="5"><span class="kw">library</span>(katadasaR)</a>
<a class="sourceLine" id="cb23-6" title="6"><span class="kw">library</span>(textclean)</a></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Dari berbagai metode klasifikasi yang telah dipelajari (logistic regression, KNN, naive bayes, decision tree, dan random forest), bagaimana pemilihan dalam penggunaan metode tersebut?</p>
<p>Pemilihan metode klasifikasi bergantung pada tujuan analisis yang dilakukan. Secara umum tujuan pemodelan klasifikasi adalah melakukan analisa terkait hubungan prediktor dengan target variabel atau melakukan prediksi.</p>
<p>Jika tujuannya adalah untuk melakukan analisa terkait hubungan antara prediktor dan target variabel dapat menggunakan logistic regression atau decision tree. Berikut kelebihan dan kekurangan dari kedua metode tersebut.</p>
<p><strong>Logistic regression:</strong></p></li>
</ol>
<ul>
<li>model klasifikasi yang cukup sederhana dan komputasinya cepat (+)</li>
<li>interpretable (+)</li>
<li>tidak mengharuskan scaling data (+)</li>
<li>baseline yang baik sebelum mencoba model yang lebih kompleks (+)</li>
<li>memerlukan kejelian saat melakukan feature engineering karena sangat bergantung pada data yang fit</li>
<li>tidak dapat mengevaluasi hubungan yang tidak linier (-)</li>
<li><p>mengharuskan antar prediktornya tidak saling terkait (cukup kaku) (-)</p>
<p><strong>Decision tree:</strong></p></li>
<li>tidak mengharuskan scaling data (+)</li>
<li>dapat mengevaluasi hubungan yang tidak linier (+)</li>
<li>antar prediktornya boleh saling berkaitan (+)</li>
<li>interpretable (+)</li>
<li>decision tree yang terbentu cenderung tidak stabil (sedikit perubahan pada data akan merubah struktur pohon yang dihasilkan) (-)</li>
<li>komputasi relatif lebih lama (-)</li>
<li><p>cenderung overfitting (-)</p>
<p>Jika tujuannya adalah melakukan prediksi dengan harapan tingkat akurasi yang tinggi, bisa menggunakan random forest. Karena metode ini merupakan metode klasifikasi yang menggabungkan beberapa metode, sehingga cukup robust (tidak sensitif) terhadap outlier, antar prediktor boleh saling berkaitan, bahkan mengatasi overfitting.</p>
<p>Naive bayes umumnya digunakan untuk masalah-masalah yang berkaitan dengan klasifikasi text. Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://towardsdatascience.com/the-naive-bayes-classifier-e92ea9f47523">The Naive Bayes Classifier</a></p></li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Apakah k-fold cross validation dapat digunakan untuk metode klasifikasi lain (selain random forest)?</li>
</ol>
<p>k-fold cross validation dapat digunakan untuk semua metode klasifikasi bahkan di luar metode klasifikasi yang telah dipelajari. Namun, karena k-fold cross validation tidak memperlihatkan hasil pemodelan untuk semua subset data (hanya mengambil yang terbaik, yaitu tingkat akurasi tertinggi), maka tetap perlu dilakukan cross validation untuk melakukan evaluasi model. Berikut contoh k-fold cross validation untuk metode lain (selain random forest).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">set.seed</span>(<span class="dv">417</span>)</a>
<a class="sourceLine" id="cb24-2" title="2">ctrl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;repeatedcv&quot;</span>, <span class="dt">number =</span> <span class="dv">5</span>, <span class="dt">repeats =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co"># parameter method dapat disesuaikan dengan metode klasifikasi yang digunakan</span></a>
<a class="sourceLine" id="cb24-4" title="4">model &lt;-<span class="st"> </span><span class="kw">train</span>(attrition <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> train, <span class="dt">method =</span> <span class="st">&quot;ctree&quot;</span>, <span class="dt">trControl =</span> ctrl)</a></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li><p>Apakah pada metode KNN, naive bayes, decision tree, dan random forest hasilnya dapat berupa probability?</p>
<p>Pada dasarnya semua metode klasifikasi akan menghasilkan probability, bukan langsung kelas. Namun, kebanyakan metode klasifikasi secara default di R langsung menghasilkan kelas (threshold 0.5). Untuk menghasilkan probability dapat menambahkan parameter <code>type</code> saat mealukan <code>predict()</code>. Berikut beberapa <code>type</code> untuk metode klasifikasi yang dipelajari:</p></li>
</ol>
<ul>
<li><code>response</code> untuk logistic regression</li>
<li><code>raw</code> untuk naive bayes</li>
<li><code>probability</code> untuk decision tree dan random forest</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>Apakah metode naive bayes dapat diterapkan untuk prediktor bertipe numerik? peluang apa yang dihitung?</li>
</ol>
<p>Naive bayes dapat diterapkan pada berbagai permasalahan klasifikasi bukan hanya pada klasifikasi text. Jika prediktor yang digunakan bertipe numerik naive bayes akan menghitung peluang rata-rata (mean) dan standard deviation (sd) untuk setiap level target. Berikut contoh naive bayes pada data <code>iris</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">naiveBayes</span>(Species <span class="op">~</span><span class="st"> </span>., iris)</a></code></pre></div>
<pre><code>#&gt; 
#&gt; Naive Bayes Classifier for Discrete Predictors
#&gt; 
#&gt; Call:
#&gt; naiveBayes.default(x = X, y = Y, laplace = laplace)
#&gt; 
#&gt; A-priori probabilities:
#&gt; Y
#&gt;     setosa versicolor  virginica 
#&gt;  0.3333333  0.3333333  0.3333333 
#&gt; 
#&gt; Conditional probabilities:
#&gt;             Sepal.Length
#&gt; Y             [,1]      [,2]
#&gt;   setosa     5.006 0.3524897
#&gt;   versicolor 5.936 0.5161711
#&gt;   virginica  6.588 0.6358796
#&gt; 
#&gt;             Sepal.Width
#&gt; Y             [,1]      [,2]
#&gt;   setosa     3.428 0.3790644
#&gt;   versicolor 2.770 0.3137983
#&gt;   virginica  2.974 0.3224966
#&gt; 
#&gt;             Petal.Length
#&gt; Y             [,1]      [,2]
#&gt;   setosa     1.462 0.1736640
#&gt;   versicolor 4.260 0.4699110
#&gt;   virginica  5.552 0.5518947
#&gt; 
#&gt;             Petal.Width
#&gt; Y             [,1]      [,2]
#&gt;   setosa     0.246 0.1053856
#&gt;   versicolor 1.326 0.1977527
#&gt;   virginica  2.026 0.2746501</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>Bagaimana cara menghapus <code>stopwords</code> dalam bahasa indonesia?</li>
</ol>
<p>Download terlebh dahulu file.txt (<code>stopwords id.txt</code>) yang berisi stopwords bahasa indonesia di internet. Kemudian import <code>stopwords id.txt</code> tersebut dengan menggunakan fungsi <code>readLines()</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" title="1"><span class="co"># import Indonesia stopwords</span></a>
<a class="sourceLine" id="cb27-2" title="2">stop_id &lt;-<span class="st"> </span><span class="kw">readLines</span>(<span class="st">&quot;data/03-C2/stopwords_id.txt&quot;</span>)</a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="co"># generate data frame</span></a>
<a class="sourceLine" id="cb27-5" title="5">text &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">sentence =</span> <span class="kw">c</span>(<span class="st">&quot;saya tertarik belajar data science di @algoritma :)&quot;</span>,</a>
<a class="sourceLine" id="cb27-6" title="6">                                <span class="st">&quot;anda tinggal di Jakarta&quot;</span>,</a>
<a class="sourceLine" id="cb27-7" title="7">                                <span class="st">&quot;Ingin ku merat🔥 na👍&quot;</span>,</a>
<a class="sourceLine" id="cb27-8" title="8">                                <span class="st">&quot;selamat tahun baru #2020 !&quot;</span>,</a>
<a class="sourceLine" id="cb27-9" title="9">                                <span class="st">&quot;pingin makan yang kek gitu&quot;</span>))</a></code></pre></div>
<p>Mengubah text dalam bentuk data frame ke bentuk corpus dengan menggunakan fungsi <code>VectorSource()</code> dan <code>VCorpus()</code> dari library <code>tm</code>. Setelah itu, baru dapat menghapus stopwords dengan menggabungkan fungsi <code>tm_map()</code> dan <code>removeWords()</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1">text_clean1 &lt;-<span class="st"> </span>text <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="st">  </span><span class="kw">pull</span>(sentence) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="st">  </span><span class="kw">VectorSource</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="st">  </span><span class="kw">VCorpus</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="st">  </span><span class="kw">tm_map</span>(removeWords, stop_id)</a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7">text_clean1[[<span class="dv">1</span>]]<span class="op">$</span>content</a></code></pre></div>
<pre><code>#&gt; [1] &quot; tertarik belajar data science  @algoritma :)&quot;</code></pre>
<ol start="6" style="list-style-type: decimal">
<li>Bagaimana cara mengubah kata berimbuhan mejadi kata dasarnya saja dalam bahasa Indonesia?</li>
</ol>
<p>Untuk mengubah kata berimbuhan menjadi kata dasar dalam bahasa Indonesia dapat menggunakan fungsi <code>katadasaR()</code> dari library <code>katadasaR</code>. Namun, fungsi tersebut hanya menerima 1 inputan (1 value) saja sehigga dibutuhkan fungsi <code>sapply()</code> untuk mengaplikasikan fungsi tersebut ke dalam 1 kalimat.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1"><span class="co"># membuat fungsi untuk mengubah kata berimbuhan menjadi kata dasar</span></a>
<a class="sourceLine" id="cb30-2" title="2">kata_dasar &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb30-3" title="3">  <span class="kw">paste</span>(<span class="kw">sapply</span>(<span class="kw">words</span>(x), katadasaR), <span class="dt">collapse =</span> <span class="st">&quot; &quot;</span>)</a>
<a class="sourceLine" id="cb30-4" title="4">  }</a></code></pre></div>
<p>Menggunakan fungsi di atas dengan menggabungkan fungsi <code>tm_map()</code> dan <code>content_transformer()</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" title="1">text_clean2 &lt;-<span class="st"> </span>text <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="st">  </span><span class="kw">pull</span>(sentence) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="st">  </span><span class="kw">VectorSource</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="st">  </span><span class="kw">VCorpus</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="st">  </span><span class="kw">tm_map</span>(<span class="kw">content_transformer</span>(kata_dasar))</a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7">text_clean2[[<span class="dv">1</span>]]<span class="op">$</span>content</a></code></pre></div>
<pre><code>#&gt; [1] &quot;saya tarik ajar data science di @algoritma :)&quot;</code></pre>
<ol start="7" style="list-style-type: decimal">
<li>Bagaiamana cara menghapus emoticon dan emoji?</li>
</ol>
<p>Untuk menghapus emoticon dan emoji dapat menggunakan fungsi <code>replace_emoji()</code> dan <code>replace_emoticon()</code> dari library <code>textclean</code>. Namun, fungsi tersebut hanya menerima tipe data berupa karakter sehingga harus diubah terlebih dahulu tipe datanya jika masih belum karakter.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" title="1">text_clean3 &lt;-<span class="st"> </span>text <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sentence =</span> <span class="kw">as.character</span>(sentence)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="st">  </span><span class="kw">pull</span>(sentence) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="st">  </span><span class="kw">replace_emoji</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="st">  </span><span class="kw">replace_emoticon</span>()</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7">text_clean3</a></code></pre></div>
<pre><code>#&gt; [1] &quot;saya tertarik belajar data science di @algoritma smiley &quot;
#&gt; [2] &quot;anda tinggal di Jakarta&quot;                                 
#&gt; [3] &quot;Ingin ku merat&lt;U+0001F525&gt; na&lt;U+0001F44D&gt;&quot;               
#&gt; [4] &quot;selamat tahun baru #2020 !&quot;                              
#&gt; [5] &quot;pingin makan yang kek gitu&quot;</code></pre>
<ol start="8" style="list-style-type: decimal">
<li>Bagaimana cara menghapus mention dan hashtag?</li>
</ol>
<p>Untuk menghapus mention dan hashtag dapat menggunakan fungsi <code>replace_hash()</code> dan <code>replace_tag()</code> dari library <code>textclean</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" title="1">text_clean4 &lt;-<span class="st"> </span>text <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sentence =</span> <span class="kw">as.character</span>(sentence)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="st">  </span><span class="kw">pull</span>(sentence) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="st">  </span><span class="kw">replace_hash</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="st">  </span><span class="kw">replace_tag</span>()</a>
<a class="sourceLine" id="cb35-6" title="6"></a>
<a class="sourceLine" id="cb35-7" title="7">text_clean4</a></code></pre></div>
<pre><code>#&gt; [1] &quot;saya tertarik belajar data science di  :)&quot;
#&gt; [2] &quot;anda tinggal di Jakarta&quot;                  
#&gt; [3] &quot;Ingin ku merat&lt;U+0001F525&gt; na&lt;U+0001F44D&gt;&quot;
#&gt; [4] &quot;selamat tahun baru  !&quot;                    
#&gt; [5] &quot;pingin makan yang kek gitu&quot;</code></pre>
<ol start="9" style="list-style-type: decimal">
<li>Bagaimana cara menghapus slang words?</li>
</ol>
<p>Untuk menghapus slang words dapat menggunakan fungsi <code>replace_internet_slang()</code> dari library <code>textclean</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" title="1">slang_id &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/03-C2/colloquial-indonesian-lexicon.csv&quot;</span>) </a>
<a class="sourceLine" id="cb37-2" title="2"></a>
<a class="sourceLine" id="cb37-3" title="3">text_clean5 &lt;-<span class="st"> </span>text <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sentence =</span> <span class="kw">as.character</span>(sentence)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="st">  </span><span class="kw">pull</span>(sentence) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb37-6" title="6"><span class="st">  </span><span class="kw">replace_internet_slang</span>(<span class="dt">slang =</span> <span class="kw">paste0</span>(<span class="st">&#39;</span><span class="ch">\\</span><span class="st">b&#39;</span>, slang_id<span class="op">$</span>slang, <span class="st">&#39;</span><span class="ch">\\</span><span class="st">b&#39;</span>) , </a>
<a class="sourceLine" id="cb37-7" title="7">                         <span class="dt">replacement =</span> slang_id<span class="op">$</span>formal, </a>
<a class="sourceLine" id="cb37-8" title="8">                         <span class="dt">ignore.case =</span> T)</a>
<a class="sourceLine" id="cb37-9" title="9"></a>
<a class="sourceLine" id="cb37-10" title="10">text_clean5</a></code></pre></div>
<pre><code>#&gt; [1] &quot;saya tertarik belajar data science di @algoritma :)&quot;
#&gt; [2] &quot;anda tinggal di Jakarta&quot;                            
#&gt; [3] &quot;Ingin ku merat&lt;untuk+0001F525&gt; nya&lt;untuk+0001F44D&gt;&quot; 
#&gt; [4] &quot;selamat tahun baru #2020 !&quot;                         
#&gt; [5] &quot;pengin makan yang kayak begitu&quot;</code></pre>
<p>Berikut link eksternal yang dapat dijadikan sebagai bahan referensi dalam melakukan cleaning text <a href="hthttps://algotech.netlify.com/blog/text-cleaning-bahasa/">TEXT CLEANING BAHASA INDONESIA</a> dan <a href="https://algotech.netlify.com/blog/textclean/">TEXT CLEANING BAHASA INGGRIS</a></p>

</div>
<div id="unsupervised-learning" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> Unsupervised Learning</h1>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" title="1"><span class="co"># libraries</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="kw">library</span>(tidyverse)</a>
<a class="sourceLine" id="cb39-3" title="3"><span class="kw">library</span>(FactoMineR)</a>
<a class="sourceLine" id="cb39-4" title="4"><span class="kw">library</span>(plotly)</a></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Penerapan PCA di industri?</p>
<p>PCA pada industri lebih sering digunakan untuk data preparation sama halnya seperti scaling, feature engineering, ataupun variable selection. PCA digunakan untuk mereduksi data besar menjadi data yang lebih kecil, secara sederhana dapat dikatakan mengurangi jumlah kolom pada data. Walaupun PCA mengurangi jumlah kolom pada data (mereduksi dimensi), PCA tetap mempertahankan semua variabel (menggunakan semua variabel). Sebelum mereduksi dimensi PCA akan merangkum terlebih dahulu semua informasi yang terdapat pada setiap variabel ke dalam bentuk PC, PC tersebut yang nantinya akan direduksi (dikurangi) dimensinya. Oleh karena itu, variabel yang digunakan jumlahnya tetap sama seperti data awal, hanya informasi (variansinya) saja yang berkurang. Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://web.cs.ucdavis.edu/~vemuri/papers/pcaVisualization.pdf">An Application of PCA</a>.</p>
<p>Contoh permasalahan yang sering ditemui adalah klasifikasi dokumen. Saat ini semua administrasi dilakukan secara online/elektronik (tidak manual), adakalanya seorang nasabah/pelamar/customer harus melakukan upload dokumen. Sebelum adanya klasifikasi dokumen, pengecekkan kebenaran dokumen dilakukan secara manual. sehingga membutuhkan waktu yang cukup lama dan kapasitas penyimpanan yang relatif besar karena apps tidak mampu memilah mana dokumen yang sudah sesuai dan mana yang belum. Namun, permasalahan tersebut sudah mampu terjawab dengan adanya klasifikasi dokumen. Data untuk klasifikasi dokumen adalah data image yang jika dilakukan proses klasifikasi akan memerlukan komputasi yang relatif lama dibandingkan data tabular biasa. Oleh karena itu, perlu dilakukan PCA untuk mereduksi dimensi data image tersebut supaya komputasi saat proses klasifikasi bisa menjadi lebih cepat. Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://www.r-bloggers.com/image-compression-with-pca-in-r/">Image Compression with PCA in R</a>.</p></li>
<li><p>Apakah biplot dapat menampilkan PC lain selain PC1 dan PC2?</p></li>
</ol>
<p>Bisa tetapi informasi yang dijelaskan menjadi berkurang, karena secara default pada R PC1 dan PC2 merangkum informasi paling banyak. Berikut contoh membuat biplot dengan menggunakan PC lain (selain PC1 dan PC2):</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">head</span>(USArrests)</a></code></pre></div>
<pre><code>#&gt;            Murder Assault UrbanPop Rape
#&gt; Alabama      13.2     236       58 21.2
#&gt; Alaska       10.0     263       48 44.5
#&gt; Arizona       8.1     294       80 31.0
#&gt; Arkansas      8.8     190       50 19.5
#&gt; California    9.0     276       91 40.6
#&gt; Colorado      7.9     204       78 38.7</code></pre>
<p>Membuat PCA dari data <code>USArrests</code> dengan menggunakan fungsi <code>prcomp()</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" title="1">pca_us &lt;-<span class="st"> </span><span class="kw">prcomp</span>(USArrests, <span class="dt">scale =</span> T)</a></code></pre></div>
<p>Membuat visualisasi dari hasil PCA dengan menggunakan fungsi <code>biplot()</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" title="1"><span class="co"># parameter `choices` dapat diganti sesuai PC yang ingin dibuat, secara default menggunakan  PC1 dan PC2 (choices = 1:2)</span></a>
<a class="sourceLine" id="cb43-2" title="2"><span class="kw">biplot</span>(pca_us, <span class="dt">choices =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">3</span>)</a></code></pre></div>
<p><img src="04-UL_files/figure-html/unnamed-chunk-4-1.png" width="672" style="display: block; margin: auto;" /></p>
<ol start="3" style="list-style-type: decimal">
<li>Dimensionality reduction mengatasi masalah high-dimensional data, permasalahan apa yang terdapat pada data berdimensi tinggi?</li>
</ol>
<ul>
<li><p>menyulitkan pengolahan data,</p></li>
<li><p>memerlukan komputasi yang besar,</p></li>
<li><p>tidak efisien secara waktu.</p></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li><p>Perbedaan membuat PCA dengan menggunakan fungsi <code>prcomp()</code> dan <code>PCA()</code> dari library <code>FactoMiner</code>?</p>
<p>Fungsi untuk membuat biplot di R:</p></li>
</ol>
<ul>
<li><p><code>biplot(prcomp())</code> -&gt; base R</p></li>
<li><p><code>plot.PCA(PCA())</code> -&gt; package FactoMineR</p>
<p>kelebihan ketika membuat PCA dengan menggunakan fungsi <code>PCA()</code> dari library <code>FactoMiner</code> adalah bisa membuat biplot lebih spesifik (memisah dua grafik yang diajdikan satu -&gt; <strong>individu/variabel</strong>) dan bisa <strong>mengkombinasikan antara variabel numerik dan kategorik</strong> dengan menggunakan fungsi <code>plot.PCA()</code>.</p></li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li><p>Apakah terdapat best practice dalam menentukan jumlah PC yang digunakan pada PCA?</p>
<p>Penentuan jumlah PC yang digunakan bergantung pada kebutuhan analisa yang dilakukan. Namun, kembali pada tujuan awal melakukan PCA, yaitu untuk mereduksi dimensi supaya analisis lanjutan yang dilakukan memiliki waktu yang relatif cepat dan ruang penyimpanan yang lebih efisien. Sehingga, seringkali seorang analis menentapkan threshold lebih dari 70-75% informasi. Maksudnya jumlah PC yang digunakan adalah jumlah PC yang sudah merangkum kurang lebih 70-75% informasi. Namun, threshold tersebut sifatnya tidak mutlak artinya disesuaikan dengan kebutuhan analisis dan bisnis. Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://www.researchgate.net/post/How_many_components_can_I_retrieve_in_principal_component_analysis">How many components can I retrieve in principal component analysis?</a>.</p></li>
<li><p>Bagaimana best practice dalam penentuan jumlah cluster?</p>
<p>Penentuan jumlah cluster yang akan dibuat bergantung pada kebutuhan bisnis dalam industri. Namun, secara statistik penentuan jumlah cluster dapat dilakukan berdasarkan penurunan wss seperti yang telah dijelaskan pada pertanyaan sebelumnya. Hal yang perlu diperhatikan, yaitu jumlah cluster yang dipilih adalah jumlah cluster yang ketika dilakukan penambahan cluster sudah tidak mengakibatkan penurunan wss yang signifikan (pada grafik berbentuk landai), kemudian disesuaikan dengan kebutuhan bisnis pada industri. Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://towardsdatascience.com/10-tips-for-choosing-the-optimal-number-of-clusters-277e93d72d92">10 Tips for Choosing the Optimal Number of Clusters</a></p></li>
<li><p>Apakah kita dapat memvisualisasikan biplot dengan 3 dimensi?</p></li>
</ol>
<p>Untuk menampilkan biplot dengan 3 dimensi dapat menggunakan function <code>plot_ly()</code> dari package <code>plotly</code>. Berikut ini akan dicontohkan memvisualisasikan biplot dari PC1, PC2, PC3 dan juga akan dibedakan setiap titik observasi dengan cluster nya. Sebelum masuk ke visualisasi, akan dicari terlebih dahulu cluster untuk setiap observasi.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" title="1"><span class="co"># Read data in</span></a>
<a class="sourceLine" id="cb44-2" title="2">whiskies &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/04-UL/whiskies.txt&quot;</span>)</a>
<a class="sourceLine" id="cb44-3" title="3"><span class="co"># Distillery column is the name of each whisky</span></a>
<a class="sourceLine" id="cb44-4" title="4"><span class="kw">rownames</span>(whiskies) &lt;-<span class="st"> </span>whiskies[,<span class="st">&quot;Distillery&quot;</span>]</a>
<a class="sourceLine" id="cb44-5" title="5"></a>
<a class="sourceLine" id="cb44-6" title="6"><span class="co"># remove RowID, Postcode, Latitude and Longitude</span></a>
<a class="sourceLine" id="cb44-7" title="7">whiskies &lt;-<span class="st"> </span>whiskies[,<span class="dv">3</span><span class="op">:</span><span class="dv">14</span>]</a>
<a class="sourceLine" id="cb44-8" title="8"></a>
<a class="sourceLine" id="cb44-9" title="9">whi_km &lt;-<span class="st"> </span><span class="kw">kmeans</span>(<span class="kw">scale</span>(whiskies), <span class="dv">4</span>)</a></code></pre></div>
<p>Setelah menggunakan <code>kmeans()</code> untuk mendapatkan cluster, berikutnya kita lakukan PCA dan membentuk PC yang diperoleh dalam bentuk data frame.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" title="1">whis.pca&lt;-<span class="kw">PCA</span>(whiskies, <span class="dt">graph =</span> F,<span class="dt">scale.unit =</span> T)</a>
<a class="sourceLine" id="cb45-2" title="2">df_pca &lt;-<span class="st"> </span><span class="kw">data.frame</span>(whis.pca<span class="op">$</span>ind<span class="op">$</span>coord) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="st">          </span><span class="kw">bind_cols</span>(<span class="dt">cluster =</span> <span class="kw">as.factor</span>(whi_km<span class="op">$</span>cluster))</a>
<a class="sourceLine" id="cb45-4" title="4"><span class="kw">head</span>(df_pca)</a></code></pre></div>
<pre><code>#&gt;         Dim.1      Dim.2      Dim.3      Dim.4       Dim.5 cluster
#&gt; 1 -0.65565655  1.2056463 -0.1663438 -0.7807432  0.14526590       3
#&gt; 2 -2.31263102  3.7479878  1.3669186  0.8719922  0.69366566       3
#&gt; 3 -1.60215288 -0.6640822 -0.2972053 -1.1027897 -0.01535638       2
#&gt; 4  5.41363278  0.2448746  1.2101422 -0.7483052 -0.19536723       4
#&gt; 5  0.12164922  0.4127927 -0.3044621 -1.2705758  1.49597271       1
#&gt; 6  0.09941062 -1.3966133 -1.2024542  1.6549138 -0.28659985       1</code></pre>
<p>Langkah berikutnya adalah memvisualisasikan PC dan membedakan warna observasi berdasarkan cluster nya.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">plot_ly</span>(df_pca,<span class="dt">x =</span> <span class="op">~</span>Dim<span class="fl">.1</span>, <span class="dt">y =</span> <span class="op">~</span>Dim<span class="fl">.2</span>, <span class="dt">z =</span> <span class="op">~</span>Dim<span class="fl">.3</span>, <span class="dt">color =</span> <span class="op">~</span>cluster)</a></code></pre></div>

</div>
<div id="time-series-and-forecasting" class="section level1">
<h1><span class="header-section-number">Chapter 5</span> Time Series and Forecasting</h1>
<ol style="list-style-type: decimal">
<li><p>Apa itu Time Series?</p>
<p>Time series merupakan data yang diperoleh dan disusun berdasarkan urutan waktu. Waktu yang digunakan dapat berupa hari, minggu, bulan, dan sebagainya.</p></li>
<li><p>Apa itu Seasonal Effects?</p>
<p>Seasonal effects terjadi jika data observasi memiliki pola yang berulang sesuai dengan siklus tertentu</p></li>
<li><p>Perbedaan times series dan regression?</p>
<p>Time series adalah analis variabel numerik berdasarkan deret waktu. Perbedaan mendasar dengan regresi, jika regresi memprediksi berdasarkan variabel independen lainnya (x1, x2, x3). Sedangkan untuk time series kita hanya mengamati variabel y yang akan kita prediksi</p></li>
<li><p>Apa arti dari nilai smoothing parameter yang mendekati nilai 1?</p>
<p>Nilai smoothing paremeter mendekati nilai 1 artinya bobot lebih besar diberikan ke data observasi terbaru</p></li>
<li><p>Pada time series forecasting, data deret waktu yang dimiliki harus lengkap tanpa ada tanggal yang hilang, bagaimana mengatasi data yang tanggal nya tidak lengkap?</p></li>
</ol>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">library</span>(lubridate)</a>
<a class="sourceLine" id="cb48-2" title="2"><span class="kw">library</span>(dplyr)</a>
<a class="sourceLine" id="cb48-3" title="3">Quantity &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb48-4" title="4">Order.Date &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;2019-01-03&quot;</span>,<span class="st">&quot;2019-01-07&quot;</span>,<span class="st">&quot;2019-01-08&quot;</span>) </a>
<a class="sourceLine" id="cb48-5" title="5">dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(Order.Date, Quantity) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb48-6" title="6"><span class="st">       </span><span class="kw">mutate</span>(<span class="dt">Order.Date =</span> <span class="kw">ymd</span>(Order.Date)) </a></code></pre></div>
<p>Gunakan function <code>pad()</code> dari package <code>padr</code> untuk memenuhi tanggal yang hilang</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" title="1"><span class="kw">library</span>(padr)</a>
<a class="sourceLine" id="cb49-2" title="2">dat <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="st">  </span><span class="kw">pad</span>()</a></code></pre></div>
<pre><code>#&gt;   Order.Date Quantity
#&gt; 1 2019-01-03        3
#&gt; 2 2019-01-04       NA
#&gt; 3 2019-01-05       NA
#&gt; 4 2019-01-06       NA
#&gt; 5 2019-01-07        4
#&gt; 6 2019-01-08        5</code></pre>
<ol start="6" style="list-style-type: decimal">
<li>Bagaimana mengisi nilai NA pada time series object?</li>
</ol>
<p><code>Fill = "extend"</code> adalah salah satu function untuk mengisi nilai NA dengan nilai disekitarnya. <a href="https://drive.google.com/file/d/1J7yIsONtK9z3fDvkxnWiEHEoWVE1zdBS/view?usp=sharing">link</a></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">library</span>(zoo)</a>
<a class="sourceLine" id="cb51-2" title="2">dat <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="st">  </span><span class="kw">pad</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="st">  </span><span class="kw">pull</span>(Quantity)  <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb51-5" title="5"><span class="st">  </span><span class="kw">ts</span>(<span class="dt">frequency =</span> <span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb51-6" title="6"><span class="st">  </span><span class="kw">na.fill</span>(<span class="dt">fill =</span> <span class="st">&quot;extend&quot;</span>) </a></code></pre></div>
<pre><code>#&gt; Time Series:
#&gt; Start = 1 
#&gt; End = 6 
#&gt; Frequency = 1 
#&gt; [1] 3.00 3.25 3.50 3.75 4.00 5.00</code></pre>
<ol start="7" style="list-style-type: decimal">
<li><p>Jika hasil decomposition pada trend masih membentuk pola berulang, apa yang terjadi?</p>
<p>Ketika hasil decomposition yang diperoleh pada trend masih membentuk pola berulang, itu artinya masih terdapat pola seasonal yang belum tertangkap, kemungkinan data yang digunakan memiliki multiple seasonal, untuk membuat object ts pada pola data multiple seasonal dapat menggunakan function msts(). Untuk penanganan multiple seasonal lebih lengkap nya dapat di cek pada link berikut ini. <a href="https://algotech.netlify.com/blog/multiple-seasonal/">multiple seasonal</a></p></li>
<li><p>Apakah pada metode arima kita dapat menambahkan variable prediktor pada analis?</p></li>
</ol>
<p>Untuk analisis time series dengan variabel prediktor lainnya dapat menggunakan parameter <code>xreg</code> pada function <code>Arima()</code> dan <code>auto.arima()</code>.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">library</span>(fpp2)</a>
<a class="sourceLine" id="cb53-2" title="2"><span class="kw">library</span>(forecast)</a>
<a class="sourceLine" id="cb53-3" title="3"><span class="kw">Arima</span>(<span class="dt">y =</span> uschange[,<span class="dv">1</span>], <span class="dt">xreg =</span> uschange[,<span class="dv">2</span>], <span class="dt">order =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>))</a></code></pre></div>
<pre><code>#&gt; Series: uschange[, 1] 
#&gt; Regression with ARIMA(1,1,0) errors 
#&gt; 
#&gt; Coefficients:
#&gt;           ar1    xreg
#&gt;       -0.5412  0.1835
#&gt; s.e.   0.0638  0.0429
#&gt; 
#&gt; sigma^2 estimated as 0.3982:  log likelihood=-177.46
#&gt; AIC=360.93   AICc=361.06   BIC=370.61</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">auto.arima</span>(<span class="dt">y =</span> uschange[,<span class="dv">1</span>], <span class="dt">xreg =</span> uschange[,<span class="dv">2</span>])</a></code></pre></div>
<pre><code>#&gt; Series: uschange[, 1] 
#&gt; Regression with ARIMA(1,0,2) errors 
#&gt; 
#&gt; Coefficients:
#&gt;          ar1      ma1     ma2  intercept    xreg
#&gt;       0.6922  -0.5758  0.1984     0.5990  0.2028
#&gt; s.e.  0.1159   0.1301  0.0756     0.0884  0.0461
#&gt; 
#&gt; sigma^2 estimated as 0.3219:  log likelihood=-156.95
#&gt; AIC=325.91   AICc=326.37   BIC=345.29</code></pre>
<p>Untuk detail lengkapnya dapat di lihat pada link berikut ini: <a href="https://otexts.com/fpp2/regarima.html">link</a></p>
<ol start="9" style="list-style-type: decimal">
<li><p>Nilai error yang harus dilihat dan diperhatikan ? Kapan menggunakan MAE/RMSE/MAPE ?</p>
<p>Tidak ada jawaban pasti untuk mengetahui penggunaan ketiga error tersebut. Tentunya setiap indikator memiliki memiliki kelebihan dan kekurangan masing-masing. Berikut ringkasan dari ketiga error tersebut:</p></li>
</ol>
<ul>
<li><p>MAE(Mean Absolute Error), hasil MAE tidak akan terpengaruh jika memiliki data outlier.</p></li>
<li><p>RMSE (Root Mean Square Error), memberikan jaminan untuk mendapatkan hasil perkiraan yang tidak bias karena cara hitungnya dengan mengkuadratkan error yang diperoleh, namun ketika memiliki data outlier pada data tentunya RMSE memiliki kecenderungan untuk memperoleh perkiraan yang besar.</p></li>
<li><p>MAPE (Mean Absolute Percentage Error), MAPE menunjukan rata-rata kesalahan absolut peramalan dalam bentuk presentase terhadap data aktual. MAPE tidak cocok jika memiliki observasi yang bernilai 0, karena cara hitung MAPE adalah dengan membagi dengan nilai aktual, hal tersebut akan menyebabkan nilai MAPE menjadi infinit.</p></li>
</ul>
<ol start="10" style="list-style-type: decimal">
<li>Apakah hasil diff manual berbeda dengan yang dilakukan pada fungsi arima atau auto.arima ?</li>
</ol>
<p>Hasil prediksi yang diperoleh ketika melakukan differencing manual kemudian diaplikasikan dengan function arima/auto.arima akan sedikit berbeda ketika langsung melakukan differencing dari function arima/auto.arima. Hal ini tentunya tidak menjadi masalah besar, karena hasil yang diperoleh tidak jauh berbeda. Untuk detail rumus yang digunakan dapat dilihat di link berikut. <a href="https://stats.stackexchange.com/questions/32634/difference-time-series-before-arima-or-within-arima">differencing</a></p>

</div>
<div id="neural-network-and-deep-learning" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Neural Network and Deep Learning</h1>
<ol style="list-style-type: decimal">
<li>Berapa jumlah hidden layer dan nodes untuk setiap hidden layer secara best practice dalam membangun arsitektur neural network (ANN) ?</li>
</ol>
<ul>
<li>Kebanyakan orang menggunakan minimal 2 hidden layer, namun tidak menutup kemungkinan menggunakan lebih dari 2 ataupun kurang dari 2 hidden layer.</li>
<li>Jumlah nodes biasanya semakin mengecil ketika hidden layers semakin dekat dengan output layer. Tujuannya adalah untuk melihat fitur dengan lebih spesifik.</li>
<li>Kebanyakan orang menggunakan angka biner <span class="math inline">\(2^{n}\)</span> seperti 1, 2, 4, 8, 16, 32, 64, 128, 256, dst karena neural network merupakan metode yang berasal dari orang computer science dan mathematics yang biasa menggunakan angka biner.</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Fungsi aktivasi apa yang sering digunakan ketika membuat arsitktur neural network ?</li>
</ol>
<ul>
<li>Pada hidden layer biasa digunakan fungsi aktivasi <code>relu</code> karena <code>relu</code> melakukan transformasi data dengan mengubah nilai negatif menjadi 0 dan membiarkan nilai positif, sehingga semakin ke belakang informasi yang dibawa tidak banyak berkurang.</li>
<li>Pada output layer: jika casenya adalah regresi digunakan fungsi aktivasi <code>linear</code>, jika casenya adalah klasifikasi biner digunakan fungsi aktivasi <code>sigmoid</code>, dan jika casenya adalah klasifikasi multiclass digunakan fungsi aktivasi <code>softmax</code>.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Bagaimana menentukan batch size dan jumlah epoch ?</li>
</ol>
<ul>
<li>Batch size biasanya menggunakan angka yang dapat membagi habis jumlah data, supaya data yang tersedia dapat digunakan secara keseluruhan (tidak ada yang tidak terpakai). Contoh:
Jika data train terdiri dari 800 observasi, kita bisa menggunakan batch size 200 yang dapat embagai habis 80 observasi.</li>
<li>Jumlah epoch dimulai dari angka yang kecil terlebih dahulu supaya komputasi yang dilakukan tidak terlalu lama, kemudian dilihat apakah error dan accuracy yang dhasilkan sudah konvergen atau belum. Jika belum bisa menambaha jumlah epoch sedikit demi sedikit, dan sebaliknya.</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li><p>Bagaimana menentukan learning rate yang tepat ?</p>
<p>Learning rate berfungsi mempercepat atau memperlambat besaran update error.</p></li>
</ol>
<ul>
<li>Semakin besar learning rate, maka error/accuracy akan semakin cepat konvergen. Namun, bisa saja titik error paling minimum (global optimum) terlewat.</li>
<li>Semakin kecil learning rate, maka terdapat kemungkinan yang lebih besar untuk sampai di titik error paling minimum (global optimum). Namun, error/accuracy akan lebih lama konvergen.</li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li><p>Optimizer apa yang paling sering digunakan ?</p>
<p>Optimizer merupakan fungsi yang digunakan untuk mengoptimumkan error (memperkecil error). Secara sederhana untuk mengoptimumkan suatu fungsi bisa melalui fungsi turunan, pada neural network disebut <code>sgd.</code> Namun, <code>sgd</code> memiliki beberapa kekurangan sehingga mulai banyak yang memperbaiki fungsi <code>sgd</code> tersebut. Untuk sekarang ini salah satu optimizer yang cukup terkenal adalah <code>adam</code> sebagai optimizer yang merupakan perbaikan dari <code>sgd</code> karena optimizer tersebut dapat mengupdate/menyesuaikan momentum ketika proses optimisasi. Berikut link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://ruder.io/optimizing-gradient-descent/index.html#adam">Adaptive Moment Estimation (Adam)</a></p>
<p>Selain tips di atas berikut link eksternal yang dapat dijadikan referensi dalam membangun arsitektur neural network <a href="https://towardsdatascience.com/17-rules-of-thumb-for-building-a-neural-network-93356f9930af">Rules-of-thumb for building a Neural Network</a></p></li>
<li><p>Perbedaan metode-metode machine learning dengan neural network dan deep learning ?</p></li>
</ol>
<ul>
<li>Neural network bukan merupakan metode yang berasal dari orang statistik melainkan lahir dari pemikiran orang-orang computer science dan math.</li>
<li><p>Neural network merupakan salah satu metode machine learning, neural network yang arsitekturnya sudah cukup rumit sering disebut sebagai deep learning. Neural network memilki <code>1</code> hidden layer, sementara deep learning memiliki <code>&gt; 1</code> hidden layer.</p>
<p>Berikut merupakan link eksternal yang dapat dijadikan sebagai bahan referensi <a href="https://parsers.me/deep-learning-machine-learning-whats-the-difference/">Deep learning &amp; Machine learning: what’s the difference?</a></p></li>
</ul>

</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc_depth": 2,
"toc_float": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
